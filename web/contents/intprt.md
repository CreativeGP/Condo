# インタプリタ制作において考えたこと

## 大まかな処理の流れ
パースが終わった前提で。

とりあえず、全ては(一応)関数である言語なので処理はルートの関数の呼び出しから始まる。
関数呼び出しには`call()`を用いる。これはただ関数内のStmtを順次実行していくだけ。
Stmtの実行には`eval()`を用いる。

## 関数

### 関数呼び出し
関数呼び出しには`call()`を用いる。これはただ関数内のStmtを順次実行していくだけ。
Stmtの実行には`eval()`を用いる。Stmtは全て以下のような構造になっているはず:

`fn arg1 arg2 ... [;]`

セミコロンに関してはStmt直上の関数値にする場合のみ省略される。

このような構造なので、`eval()`の動きとしては`fn`で束縛された関数を後ろの引数と共に`call()`に投げるということになる。

### 引数の処理
関数呼び出しをする際に、

>`eval()`の動きとしては`fn`で束縛された関数を後ろの引数と共に`call()`に投げるということになる。

と書いた部分で引数がまた関数であった場合にﾁｮｯﾄﾑｽﾞｶｼｲ。
これは`call()`に投げて帰ってきたStmtを代わりにするのだが、ここで即時実行関数とそうでないものについて考えたくなってくる。

### 即時実行関数
プログラム内に書いた`()`は、**何かに束縛されていない限り**即時実行関数として`eval()`に入ってきた時に実行される。

束縛する方法は`let`を使うか引数に渡すこと。`let`を使うと束縛表に縛られて`eval()`からの呼び出しを待つ。引数に渡すと内部で(本当は内部でやりたくない)束縛される。



## 物

### 型
型は様々な値を抽象化したものという定義は良いけど、値とは何なのか。

全くわからないので、とりあえずプログラム内に出現する物を値としてみる。



型は

### 物
Nimの方で全ての物を抽象化した型が欲しくなってくる。
これは文字列としてでしか表現できないはずなので`seq[Base]`にすることにする。
これは定義的には`Stmt`と同じだけど、Stmtは**セミコロンまで入った１つの文**という意味も持っていて、ここで必要なのはただの文字列の配列(Stmtの破片)なので。


## スコープ
基本的には普通に関数で階層的に区切ってやれば良い。

```python
(
    a = 1; # † root

    foo = (
        # a が見える
        b = 2; # † foo
    ); # † root

    (
        # a が見える
        # b は見えない
        c = 2;
    );
)
```

複雑になってくるのは関数束縛をやり始めた時...?

```python
(
    x = 6;
    foo = (|i| i + x); # † root
    
    foo 10;
)
```

## ビルドイン関数

### let
直上の関数に束縛する関数.

以下の様な順序にするようにしましょう.


```
let name type fn
```
